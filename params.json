{"name":"Splash","tagline":"Parallelizing Stochastic Learning on Spark","body":"# Introducing Splash\r\n\r\n**Stochastic algorithm** processes a large-scale dataset by sequentially processing its random samples. Typical examples of stochastic algorithm include **stochastic gradient descent**, **Gibbs sampling** and **stochastic variational inference**. Stochastic algorithms are often order-of-magnitude faster than batch processing algorithms. Below is a comparison of SGD and parallel gradient descent:\r\n\r\n<p align=\"center\">\r\n<img src=\"https://raw.githubusercontent.com/zhangyuc/splash/gh-pages/images/sgd.png\" width=\"350\"><br>\r\n</p>\r\n\r\n**Splash** is a user-friendly programming interface for developing and running stochastic algorithms on distributed systems. The main features of Splash are:\r\n\r\n* **Easy programming**: User develop single-thread algorithms via Splash: no communication protocol, no conflict management, no data partitioning, no hyper-parameter tunning.\r\n\r\n* **Fast Performance**: Splash adopts novel strategies for automatic parallelization, so that inter-machine communication is no longer a performance bottleneck. Splash allows lightening-fast learning on commercial distributed systems such as Amazon EC2. Below is the running time of Splash and other algorithms for achieving the same learning accuracy:\r\n\r\n<p align=\"center\">\r\n<img src=\"https://raw.githubusercontent.com/zhangyuc/splash/gh-pages/images/bar-sgd.png\" width=\"350\">\r\n<img src=\"https://raw.githubusercontent.com/zhangyuc/splash/gh-pages/images/bar-svi.png\" width=\"350\"><br>\r\n</p>\r\n\r\n* **Integration with Apache Spark**: Splash is built on [Apache Spark](https://spark.apache.org/). it takes the resilient distributed dataset (RDD) of Spark as input and generates RDD as output. It works seamlessly with other data analysis tools in the Spark environment, including the [MLlib machine learning library](https://spark.apache.org/mllib/). \r\n\r\n# Install Splash\r\n\r\nTo install Splash, you need to:\r\n\r\n1. Download and install [scala](http://www.scala-lang.org/index.html), [sbt](http://www.scala-sbt.org/index.html) and [Apache Spark](https://spark.apache.org/).\r\n2. Download the [Splash jar file](https://github.com/zhangyuc/splash/blob/master/target/scala-2.10/splash_2.10-0.0.1.jar?raw=true) and put it in your project classpath.\r\n3. Make SPLASH as a dependency when [submitting Spark jobs](http://spark.apache.org/docs/1.2.1/submitting-applications.html).\r\n\r\n# Quick Start\r\n\r\n## Import Splash\r\n\r\nWhen Splash is in your project classpath, you can write a self-contained application using the Splash API. Besides importing Spark packages, you also need to import the Splash package in scala, by typing:\r\n\r\n```scala\r\nimport splash._\r\n```\r\n\r\n## Create Dataset\r\n\r\nJust as every Spark applications, the first step is to create a dataset for the learning algorithm. Splash provides an abstraction called **parametrized RDD**. The parametrized RDD is very similar to the resilient distributed dataset (RDD) of Spark, but it has particular data structure for maintaining the parameters to be learnt. A parametrized RDD can be created by a standard RDD:\r\n\r\n```scala\r\nval paramRdd = new ParametrizedRDD(data)\r\n```\r\n\r\nwhere `data` is a standard RDD object containing your dataset. \r\n\r\n## Define Data Processing Function\r\n\r\nTo execute the learning algorithm on the dataset, set a data processing function `process` to the parametrized RDD by\r\n\r\n```scala\r\nparamRdd.setProcessFunction(process)\r\n```\r\n\r\nThe `process` function is implemented by the user. It takes four objects as input: a random sample from the dataset, the weight of this sample, the set of shared variables used by the stochastic algorithm and the set of local variables associated with the data element. The `process` function should be able to process a sequence of weighted samples. **The capability of processing weighted samples is mandatory** even if the original data is unweighted. This is because that Splash will automatically assign non-trivial weights to random samples as a part of its parallelization strategy. An exemplary implementation for **logistic regression** update is:\r\n\r\n```scala\r\nval process = (element: (Int, Array[Int], Array[Double]), weight: Double, sharedVar : SharedVariableSet,  localVar: LocalVariableSet) => {\r\n  val y = element._1\r\n  val x_key = element._2\r\n  val x_value = element._3\r\n  \r\n  val t = sharedVar.get(\"t\")\r\n  val learningRate = sharedVar.get(\"learning.rate\")\r\n  var sum = 0.0\r\n  for(i <- 0 until x_key.length){\r\n    // get the shared variable value by key \"w:\"+x_key(i)\r\n    sum += sharedVar.get(\"w:\"+x_key(i)) * x_value(i)\r\n  }\r\n  \r\n  for(i <- 0 until x_key.length)\r\n  {\r\n    val delta = weight * learningRate / math.sqrt( t + 1 ) * y / (1.0 + math.exp(y*sum)) * x_value(i)\r\n    // increase the shared variable by delta\r\n    sharedVar.add(\"w:\" + x_key(i), delta)\r\n  }\r\n  // increase the shared variable by weight\r\n  sharedVar.add(\"t\", weight)\r\n}\r\n```\r\n\r\nin the above code, the data element `element` has three components: a binary label equal to -1 or 1, an array of feature indices and an array of feature values. The line of code\r\n\r\n```scala\r\nsum += sharedVar.get(\"w:\"+x_key(i)) * x_value(i)\r\n```\r\n\r\naccesses the weight associated with the feature index `x_key(i)`. These weights are used to compute a linear combination of feature values, and compute the the gradient of the logistic loss. Then, the shared vector is updated by taking a small step towards the opposite direction of the gradient. We make the stepsize proportional to the weight, which is the simplest way of processing weighted samples:\r\n\r\n```scala\r\nval delta = weight * learningRate / math.sqrt( t + 1 ) * y  / (1.0 + math.exp(y*sum)) * x_value(i)\r\nsharedVar.add(\"w:\" + x_key(i), delta)\r\n```\r\n\r\nThere is another shared variable `t` counting the number of elements. It controls the stepsize of stochastic gradient descent, making it decreasing to zero as more and more samples are processed. Similarly, it is updated by calling the `get` and `add` function.\r\n\r\nMore generally, the value of local/shared variables are accessed by the `get` function by typing\r\n```scala\r\nval v1 = localVar.get(key)\r\nval v2 = sharedVar.get(key)\r\n```\r\nLocal variables are updated by directly putting a new value to the key:\r\n```scala\r\nlocalVar.set(key,value)\r\n```\r\nwhile shared variables can be updated by putting the incremental change:\r\n```scala\r\nsharedVar.add(key,delta)\r\n```\r\nwhere `delta` is the difference between the new value and the old value. Besides the `add` operation, Splash  provides many flexible ways to manipulate the shared variable. There are multiple supported types of shared variables as well. See the Splash API for more options.\r\n\r\n## Running the Algorithm\r\n\r\nAfter setting up the processing function, the user calls `run` to start running the stochastic algorithm:\r\n```scala\r\nval spc = new StreamProcessContext\r\nparamRdd.streamProcess(spc)\r\n```\r\nThe stream process context `spc` provides interfaces to control the algorithm execution. The user can specify the number of parallel threads, the proportion of data to process per iteration, the strategy for combining parallel updates, etc. See the Splash API for more details. In this example, we use the system's default setting. In the default setting, the algorithm takes one pass over the dataset by one calling of `run`. In most machine learning applications, the user wants to call `run` multiple times to take multiple passes over the dataset, in order to obtain higher learning accuracy.\r\n\r\n## Output and Evaluation\r\n\r\nAfter processing the data, the shared variable set can be accessed by:\r\n```scala\r\nval sharedVar = paramRdd.getFirstSharedVariable()\r\n```\r\nwhich returns the shared variable set maintained by the first RDD partition. The user can also query the shared variable set from all RDD partitions by call `paramRdd.getAllSharedVariable()`. It is also possible to manipulate the parametrized RDD directly. For example, by calling\r\n```scala\r\nval loss = paramRdd.map(evaluateLoss).reduce( _ + _ )\r\n```\r\nevery element in the dataset is processed by the `evaluateLoss` function. The resulting losses are aggregated by the `reduce` operator. The `map` operator for parametrized RDD is different from the standard `map` in that it is granted access to not only a data element, but also the associated local and shared variables. As a concrete example, we define a function for evaluating the logistic loss:\r\n```scala\r\nval evaluateLoss = (element: (Int, Array[String], Array[Double]), sharedVar : ParameterSet,  localVar: ParameterSet ) => {\r\n  val y = element._1\r\n  val x_key = element._2\r\n  val x_value = element._3\r\n  \r\n  var sum = 0.0\r\n  for(i <- 0 until x_key.length){\r\n    sum += sharedVar.get(\"w:\" + x_key(i)) * x_value(i)\r\n  }\r\n  math.log( 1.0 + math.exp( - y * sum ) )\r\n}\r\n```\r\nIt provides a convenient way to evaluate the performance of the algorithm. See Splash API for more options of manipulating the parametrized RDD.\r\n\r\n## Try Logistic Regression Example\r\n\r\nTo run the logistic regression example (with stochastic gradient descent), download the [Splash example](https://github.com/zhangyuc/splash/blob/master/examples/SplashExample.tar.gz?raw=true) and extract it at any directory. The Splash library is included in the package, so you don't have to download it again. To run the code, `cd` into that directory, then compile the code by typing:\r\n```\r\nsbt package\r\n```\r\nIt generates a jar file at `./target/scala-2.10/simpleapp_2.10-1.0.jar`. We submit this jar file as a Spark job by typing\r\n```\r\nYOUR_SPARK_HOME/bin/spark-submit --class \"SimpleApp\" \\\r\n--driver-memory 4G \\\r\n--jars lib/splash_2.10-0.0.1.jar target/scala-2.10/simpleapp_2.10-1.0.jar \\\r\ndata/covtype.txt 20.0 > output.txt\r\n```\r\nHere, `SimpleApp` is the class name of the logistic regrsesion app. The file `splash_2.10-0.0.1.jar` is the Splash library and `simpleapp_2.10-1.0.jar` is the compiled code to be executed. The two arguments of the app are `data/covtype.txt` and `20.0`, which stand for the location of the data file and the learning rate. The result is output to `output.txt`.\r\n\r\nAfter the algorithm terminates (it takes 100 passes over the dataset), the output should be like:\r\n```\r\nStochastic Gradient Descent\r\nTime = 1.569; Loss = 0.51655464; Group Number = 8\r\nTime = 2.479; Loss = 0.51724066; Group Number = 8\r\nTime = 3.205; Loss = 0.51601006; Group Number = 8\r\nTime = 4.165; Loss = 0.51608476; Group Number = 8\r\nTime = 4.838; Loss = 0.51621126; Group Number = 8\r\n...\r\n```\r\nEach line corresponds to the outcome after an additional pass over the dataset. The three quantities are the total time elapsed, the average logistic loss and a hyper-parameter automatically chosen by the Splash executor. It stands for the number of groups in which the system cluster the parallel threads. Splash reweights elements in each group, aggregate incremental updates within the group, and average updates across groups. Although these implementation details are hidden from the user, the group number is usually helpful in monitoring the statues of the system.\r\n\r\n# Splash API\r\n\r\nIn this section, we provide a brief description on the Splash API. \r\n\r\n## Parametrized RDD Operations\r\n\r\nThe parametrized RDD provides a similar set of operations that are supported by Spark RDD. Since the parametrized RDD maintains local variables and shared variables, there are additional operations manipulating these data structures.\r\n\r\n Operation | Meaning\r\n  --- | ---\r\nthis(rdd) | Constructor. It returns a Parametrized RDD object constructed from `rdd`. There is an optional boolean argument `preservePartitions`. If `preservePartitions = true`, then the partitioning of `rdd` is preserved. Otherwise, the original RDD is repartitioned such that the number of partitions is equal to the number of available cores. The default value of `preservePartitions` is `false`.\r\nmap(*func*)       | Return a RDD formed by mapping each element by function `func`. The function takes the element and the associated local/shared variables as input\r\nforeach(*func*)       | Process each element by function `func`. The function takes the element and the associated local/shared variables as input.\r\nmapSharedVariable (*func*)  | Return a RDD formed by mapping the shared variable set by function `func`.\r\nforeachSharedVariable (*func*) | Process the shared variable set by function `func`.\r\nsyncSharedVariable() | Synchronize the shared variable across all partitions. This operation often follows the execution of the above four operations. If the shared variables is manually changed but not synchronized, the change may not actually take effect.\r\ngetFirstSharedVariable() | Return the set of shared variables in the first partition.\r\ngetAllSharedVariable() | Return an array of the set of shared variables in all partitions.\r\nsetProcessFunction (*func*) | Set the data processing function. The function `func` takes an arbitrary element, the weight of the element and the associated local/shared variables. It performs update on the local/shared variables.\r\nsetLossFunction(*func*) | Set a loss function for the stochastic algorithm. The function `func` takes an element and the associated local/shared variables. It returns the loss incurred by this element. Setting a loss function for the algorithm is optional, but a reasonable loss function may help Splash choosing a better parallelization strategy.\r\nrun(*spc*) | Use the data processing function to process the dataset. `spc` is a StreamProcessContext object. It includes hyper-parameters for running the algorithm.\r\n\r\n## Shared Variable Set Operations\r\n\r\nAll shared variables are organized as a SharedVariableSet instance. There are operations for reading and writing the shared variable set.\r\n\r\n Operation | Meaning\r\n  --- | ---\r\nget(*key*) | Return the value of the key.\r\nadd(*key*, *delta*) | Add `delta` to the value of the key.\r\ndelayedAdd(*key*, *delta*) | Same as `add`, but the operation will not be executed instantly. Instead, it will be executed at the next time the same element is processed. The delayed operation is useful for reversing a previous operation on the same element, or for passing information to the future.\r\nmultiply(*key*, *gamma*) | Multiply the value of the key by `gamma`.\r\ndeclareArray(*key*, *length*) | Declare an array associated with the `key`. The `length` argument indicates the dimension of the array. The array has to be declared before manipulated. Generally speaking, manipulating an array of real numbers is faster than manipulating the same number of key-value pairs.\r\ngetArray(*key*) | Return the array associated with the key.\r\ngetArrayElement(*key*, *ind*) | Return the array element with index `ind`.\r\naddArray(*key*, *delta*) | Add an array `delta` to the array associated with the key. \r\naddArrayElement (*key*, *ind*, *delta*) | Add `delta` to the array element with index `ind`.\r\ndelayedAddArray (*key*, *delta*) | The same as `addArray`, but the operation will not be executed until the next time the same element is processed.\r\ndelayedAddArrayElement (*key*, *delta*, *delta*) | The same as `addArrayElement`, but the operation will not be executed until the next time the same element is processed.\r\nmultiplyArray (*key*, *gamma*) | Multiply all elements of the array by a real number `gamma`. The computation complexity of this operation is **O(1)**, independent of the dimension of the array.\r\n\r\n## Stream Process Context\r\n\r\nThe Stream Process Context allows the user setting customized properties for the algorithm execution. Given a Stream Process Context object `spc`, the properties are set by\r\n```scala\r\nspc = spc.set(propertyName,propertyValue)\r\n``` \r\nHere is a list of configurable properties:\r\n\r\nProperty Name | Default | Meaning\r\n--- | :---: | ---\r\nnum.of.thread | 0 | The number of parallel threads for algorithm execution. If `num.of.thread = 0`, then the number of parallel thread is equal to the number of partitions.\r\nnum.of.group | 0 | Indicate the number of groups that Splash clusters the parallel threads. It is a system-level parameter. If `num.of.group = 0`, then the group number will be automatically chosen.\r\ndata.per.iteration | 1.0 | Proportion of data processed per one call of the `run` function.\r\nwarmStart | true | If `warmStart = true`, then at the first time the `run` function is called, the system will not execute parallel processing immediately. It will begin by running the algorithm sequentially on a small fraction of data as a warm start. This feature can be turned off by setting `warmStart = false`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}